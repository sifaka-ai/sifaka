"""Base validator class for Sifaka.

This module provides a base validator class that implements consistent error handling
and validation patterns for all validators in the Sifaka framework. It includes the
BaseValidator class, ValidatorProtocol, and utility functions for validation.

The BaseValidator class provides common functionality for validators, including:
- Consistent error handling
- Validation result creation
- Empty text handling
- Performance tracking

Example:
    ```python
    from sifaka.validators.base import BaseValidator
    from sifaka.results import ValidationResult

    class MyValidator(BaseValidator):
        def __init__(self, min_length: int, name: str = "MyValidator"):
            super().__init__(name=name)
            self.min_length = min_length

        def _validate(self, text: str) -> ValidationResult:
            if len(text) < self.min_length:
                return ValidationResult(
                    passed=False,
                    message=f"Text is too short (minimum: {self.min_length})",
                    score=0.0,
                    issues=[f"Text length ({len(text)}) is less than minimum ({self.min_length})"],
                    suggestions=[f"Add at least {self.min_length - len(text)} more characters"]
                )
            return ValidationResult(
                passed=True,
                message="Text meets length requirements",
                score=1.0
            )

    # Create and use the validator
    validator = MyValidator(min_length=10)
    result = validator.validate("Hello")

    print(f"Validation passed: {result.passed}")
    print(f"Message: {result.message}")
    ```
"""

import logging
import time
from typing import Any, Optional, Protocol, TypeVar, runtime_checkable

from sifaka.interfaces import ValidationResult, Validator
from sifaka.results import ValidationResult as SifakaValidationResult
from sifaka.utils.error_handling import log_error, validation_context
from sifaka.utils.validation_wrapper import wrap_validation_result

# Configure logger
logger = logging.getLogger(__name__)

# Type variable for generic validators
T = TypeVar("T")


@runtime_checkable
class ValidatorProtocol(Protocol):
    """Protocol for validators that check if text meets specific criteria.

    This protocol defines the interface that all validators must implement.
    It requires a validate method that checks text against specific criteria
    and a name property that returns the validator's name.

    Validators implementing this protocol can be used with the Chain class
    to validate text generated by language models.

    Example:
        ```python
        from typing import Protocol, runtime_checkable
        from sifaka.interfaces import ValidationResult

        @runtime_checkable
        class ValidatorProtocol(Protocol):
            def validate(self, text: str) -> ValidationResult:
                ...

            @property
            def name(self) -> str:
                ...

        def use_validator(validator: ValidatorProtocol, text: str) -> bool:
            result = validator.validate(text)
            return result.passed
        ```
    """

    def validate(self, text: str) -> ValidationResult:
        """Validate text against specific criteria.

        Args:
            text (str): The text to validate.

        Returns:
            ValidationResult: A result object indicating whether the text meets
                the validation criteria, with details about any issues found.
        """
        ...

    @property
    def name(self) -> str:
        """Get the name of the validator.

        Returns:
            str: The name of the validator.
        """
        ...


class BaseValidator(Validator):
    """Base class for all validators in Sifaka.

    This class provides common functionality for validators, including:
    - Consistent error handling
    - Validation result creation
    - Empty text handling
    - Performance tracking

    All validators should inherit from this class to ensure consistent behavior.
    Subclasses only need to implement the _validate method to provide specific
    validation logic.

    Attributes:
        _name (str): The name of the validator.
        _options (Dict[str, Any]): Additional options for the validator.

    Example:
        ```python
        from sifaka.validators.base import BaseValidator
        from sifaka.results import ValidationResult

        class WordCountValidator(BaseValidator):
            def __init__(self, min_words: int, max_words: int, name: str = "WordCountValidator"):
                super().__init__(name=name)
                self.min_words = min_words
                self.max_words = max_words

            def _validate(self, text: str) -> ValidationResult:
                word_count = len(text.split())

                if word_count < self.min_words:
                    return ValidationResult(
                        passed=False,
                        message=f"Text has too few words (minimum: {self.min_words})",
                        score=0.0,
                        issues=[f"Word count ({word_count}) is less than minimum ({self.min_words})"],
                        suggestions=[f"Add at least {self.min_words - word_count} more words"]
                    )

                if word_count > self.max_words:
                    return ValidationResult(
                        passed=False,
                        message=f"Text has too many words (maximum: {self.max_words})",
                        score=0.0,
                        issues=[f"Word count ({word_count}) exceeds maximum ({self.max_words})"],
                        suggestions=[f"Remove at least {word_count - self.max_words} words"]
                    )

                return ValidationResult(
                    passed=True,
                    message="Text meets word count requirements",
                    score=1.0
                )
        ```
    """

    def __init__(self, name: Optional[str] = None, **options: Any):
        """Initialize the validator.

        Args:
            name (Optional[str]): Optional name for the validator. If not provided,
                the class name will be used.
            **options (Any): Additional options for the validator. These can be
                accessed through the _options attribute.
        """
        self._name = name or self.__class__.__name__
        self._options = options

    @property
    def name(self) -> str:
        """Get the name of the validator.

        Returns:
            str: The name of the validator, either provided during initialization
                or derived from the class name.
        """
        return self._name

    def configure(self, **options: Any) -> None:
        """Configure the validator with new options.

        This method allows updating the validator's configuration after initialization.
        Subclasses should override this method to handle specific configuration options,
        but should always call the parent class's configure method to ensure that
        options are properly updated.

        Args:
            **options (Any): Configuration options to apply to the validator.
                These will be added to the _options dictionary.

        Example:
            ```python
            # Create a validator
            validator = LengthValidator(min_words=100)

            # Configure it with new options
            validator.configure(min_words=50, max_words=200)
            ```
        """
        # Update options
        self._options.update(options)
        logger.debug(f"Configured validator '{self.name}' with options: {options}")

    def validate(self, text: str) -> ValidationResult:
        """Validate text against specific criteria.

        This method handles the validation process, including:
        - Checking for empty text
        - Setting up error handling
        - Calling the _validate method to perform specific validation logic
        - Wrapping the result to ensure it conforms to the ValidationResult protocol

        Subclasses should not override this method. Instead, they should
        override the _validate method to implement specific validation logic.

        Args:
            text (str): The text to validate.

        Returns:
            ValidationResult: A result object indicating whether the text meets
                the validation criteria, with details about any issues found.

        Raises:
            ValidationError: If validation fails due to an error.

        Example:
            ```python
            # Create a validator
            validator = LengthValidator(min_words=100)

            # Validate text
            result = validator.validate("Some text to validate")

            # Check the result
            if result.passed:
                print("Validation passed!")
            else:
                print(f"Validation failed: {result.message}")
                for issue in result.issues:
                    print(f"- {issue}")
            ```
        """
        start_time = time.time()

        try:
            # Handle empty text
            if not text or not text.strip():
                return self._create_empty_text_result()

            # Perform validation
            with validation_context(validator_name=self.name):
                result = self._validate(text)

            # Add processing time
            if hasattr(result, "details") and result.details is not None:
                result.details["processing_time_ms"] = (time.time() - start_time) * 1000

            # Wrap the result to ensure it conforms to the ValidationResult protocol
            return wrap_validation_result(result)

        except Exception as e:
            # Log the error
            log_error(e, logger, component="Validator", operation=f"{self.name}.validate")

            # Create an error result
            return wrap_validation_result(self._create_error_result(e, start_time))

    def _validate(self, text: str) -> SifakaValidationResult:  # noqa
        """Implement specific validation logic.

        This method should be overridden by subclasses to implement
        specific validation logic. It is called by the validate method
        after handling empty text and setting up error handling.

        Args:
            text (str): The text to validate.

        Returns:
            SifakaValidationResult: A result object indicating whether the text meets
                the validation criteria, with details about any issues found.

        Raises:
            NotImplementedError: If not overridden by subclasses.
            ValidationError: If validation fails due to an error.
        """
        raise NotImplementedError("Subclasses must implement _validate method")

    def _create_empty_text_result(self) -> ValidationResult:
        """Create a validation result for empty text.

        This helper method creates a standard validation result for empty text,
        indicating that validation failed because the text is empty.

        Returns:
            ValidationResult: A result object indicating that validation failed
                because the text is empty.
        """
        return wrap_validation_result(
            SifakaValidationResult(
                passed=False,
                message="Empty text is not valid",
                score=0.0,
                issues=["Text is empty"],
                suggestions=["Provide non-empty content"],
                _details={
                    "validator_name": self.name,
                    "error_type": "EmptyText",
                },
            )
        )

    def _create_error_result(self, error: Exception, start_time: float) -> ValidationResult:
        """Create a validation result for an error.

        This helper method creates a standard validation result for an error that
        occurred during validation, indicating that validation failed because of
        the error.

        Args:
            error (Exception): The exception that occurred during validation.
            start_time (float): The time when validation started, used to calculate
                the processing time.

        Returns:
            ValidationResult: A result object indicating that validation failed
                because of an error, with details about the error.
        """
        processing_time = (time.time() - start_time) * 1000  # Convert to milliseconds

        return wrap_validation_result(
            SifakaValidationResult(
                passed=False,
                message=f"Validation error: {str(error)}",
                score=0.0,
                issues=[f"Validation error: {str(error)}"],
                suggestions=["Check input format or try again"],
                _details={
                    "validator_name": self.name,
                    "error_type": type(error).__name__,
                    "error_message": str(error),
                    "processing_time_ms": processing_time,
                },
            )
        )


def safe_validate(validator: ValidatorProtocol, text: str) -> ValidationResult:
    """Safely validate text with a validator.

    This utility function wraps validator.validate with error handling
    to ensure that validation errors are properly handled and don't
    propagate to the caller. It's useful when you want to ensure that
    validation always returns a result, even if the validator raises
    an exception.

    Args:
        validator (ValidatorProtocol): The validator to use.
        text (str): The text to validate.

    Returns:
        ValidationResult: A result object indicating whether the text meets
            the validation criteria, with details about any issues found.
            If an error occurs during validation, the result will indicate
            failure with error details.

    Example:
        ```python
        from sifaka.validators.base import safe_validate
        from sifaka.validators import length

        # Create a validator
        validator = length(min_words=100)

        # Safely validate text
        result = safe_validate(validator, "Some text to validate")

        # Check the result
        if result.passed:
            print("Validation passed!")
        else:
            print(f"Validation failed: {result.message}")
        ```
    """
    start_time = time.time()

    try:
        return validator.validate(text)
    except Exception as e:
        # Log the error
        log_error(e, logger, component="Validator", operation=f"{validator.name}.validate")

        # Create an error result
        processing_time = (time.time() - start_time) * 1000  # Convert to milliseconds

        return wrap_validation_result(
            SifakaValidationResult(
                passed=False,
                message=f"Validation error: {str(e)}",
                score=0.0,
                issues=[f"Validation error: {str(e)}"],
                suggestions=["Check input format or try again"],
                _details={
                    "validator_name": getattr(validator, "name", validator.__class__.__name__),
                    "error_type": type(e).__name__,
                    "error_message": str(e),
                    "processing_time_ms": processing_time,
                },
            )
        )
